
///////////////////////
///Import data/////////
///////////////////////


//import study area
var study_area = ee.FeatureCollection("users/ahanburybrown/study_area");
exports.study_area = study_area;

//Import terrain layers
var dem = ee.Image("USGS/SRTMGL1_003");
var srtm = dem;
var degree2radian = 0.01745;


//Import training data
var training2014 = ee.FeatureCollection("users/ahanburybrown/train2014pctCov"),
    training2015 = ee.FeatureCollection("users/ahanburybrown/train2015pctCov"),
    training2016 = ee.FeatureCollection("users/ahanburybrown/train2016pctCov"),
    training2017 = ee.FeatureCollection("users/ahanburybrown/train2017pctCov"),
    training2019 = ee.FeatureCollection("users/ahanburybrown/train2019pctCov"),
    training2021 = ee.FeatureCollection("users/ahanburybrown/train2021pctCov");




//////////////////
////projections///
//////////////////

//target projection
var targetProjection = ee.Image('users/ahanburybrown/aet1981_2010_ave_HST_1646345520_N_sierras').projection();
exports.targetProjection = targetProjection;

//landsat projection
var landsatProjection = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
 .filterBounds(study_area)
 .filterDate('1986-06-30','1986-09-30')
 .first().projection();
 
//print(landsatProjection,'landsat proj');
 
exports.landsatProjection = landsatProjection;


//////////////////////
///set Parameters/////
//////////////////////

var inBands = ee.List(['B2','B3','B4','B5','B6','B7']);
var outBands = ee.List(['blue','green','red','nir','swir1','swir2']);
var LandsatVizParams = {bands: ['red', 'green', 'blue'], min: 0, max: 1000};


////////////////////
//Define Functions//
////////////////////

//function to predict conifer cover from landsat 8 imagery
var conCoverL8 = function(year){
  var yearString = ee.String(year);
  var collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
 .filterBounds(study_area)
 .filterDate(yearString.cat('-06-30'), yearString.cat('-09-30'))
 .filter(ee.Filter.lt('CLOUD_COVER_LAND', 15))
 .map(prepOli)
 .map(addQualityBands);
 
var img = terrainCorrection(collection).qualityMosaic('nd');
//var img = reduceResolution(img,landsatProjection,targetProjection);
//.updateMask(studyPixels); //this line is new.
//var nativeProj = collection.first().projection();
//var img_targetProj = reduceResolution(img,nativeProj,targetProjection);
return(CalcConProb(img).rename(ee.String('pctConCov').cat(yearString)));
};

//function to predict conifer cover from landsat 7 imagery
var conCoverL7 = function(year){
  var yearString = ee.String(year);
  var collection = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
 .filterBounds(study_area)
 .filterDate(yearString.cat('-06-30'), yearString.cat('-09-30'))
 .filter(ee.Filter.lt('CLOUD_COVER_LAND', 15))
 .map(prepEtm)
 .map(addQualityBands);
var img = terrainCorrection(collection).qualityMosaic('nd');
//var img = reduceResolution(img,landsatProjection,targetProjection);

//.updateMask(studyPixels); //this line is new.

return(CalcConProb(img).rename(ee.String('pctConCov').cat(yearString)));
};


//function to predict conifer cover from landsat 5 imagery
var conCoverL5 = function(year){
  var yearString = ee.String(year);
  var collection = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
 .filterBounds(study_area)
 .filterDate(yearString.cat('-06-30'), yearString.cat('-09-30'))
 .filter(ee.Filter.lt('CLOUD_COVER_LAND', 15))
 .map(prepEtm)
 .map(addQualityBands);
var img = terrainCorrection(collection).qualityMosaic('nd');
//var img = reduceResolution(img,landsatProjection,targetProjection);

//.updateMask(studyPixels); //this line is new.

return(CalcConProb(img).rename(ee.String('pctConCov').cat(yearString)));
};



//function to make an outline of a polygon
var MapOutline = function(featureCollection,LayerName){
var empty = ee.Image().byte();
var outline = empty.paint({
  featureCollection: featureCollection,
  color: 1,
  width: 3
});
Map.addLayer(outline, {palette: '148A3F'}, LayerName);
};
exports.MapOutline = MapOutline;

////////////////////////////////////////////////////////
/////Functions to Harmonize Landsat Time Series/////////
////////////////////////////////////////////////////////

///ETM to OLI linear transformation coefficients (Roy et al., 2016)
var coefficients = {
  itcps: ee.Image.constant([0.0003, 0.0088, 0.0061, 0.0412, 0.0254, 0.0172])
             .multiply(10000),
  slopes: ee.Image.constant([0.8474, 0.8483, 0.9047, 0.8462, 0.8937, 0.9071])
};


// Function to get and rename bands of interest from OLI.
function renameOli(img) {
  return img.select(
      ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'pixel_qa'],
      ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'pixel_qa']);
}

// Function to get and rename bands of interest from ETM+.
function renameEtm(img) {
  return img.select(
      ['B1', 'B2', 'B3', 'B4', 'B5', 'B7', 'pixel_qa'],
      ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'pixel_qa']);
}

function etmToOli(img) {
  return img.select(['blue', 'green', 'red', 'nir', 'swir1', 'swir2'])
      .multiply(coefficients.slopes)
      .add(coefficients.itcps)
      .round()
      .toShort()
      .addBands(img.select('pixel_qa'));
}

//Function to calculate NBR
function calcNbr(img) {
  return img.normalizedDifference(['NIR', 'SWIR2']).rename('NBR');
}

//Cloud and shadow masking
function fmask(img) {
  var cloudShadowBitMask = 1 << 3;
  var cloudsBitMask = 1 << 5;
  var qa = img.select('pixel_qa');
  var mask = qa.bitwiseAnd(cloudShadowBitMask)
                 .eq(0)
                 .and(qa.bitwiseAnd(cloudsBitMask).eq(0));
  return img.updateMask(mask);
}

// Define function to prepare OLI images.
function prepOli(img) {
  var orig = img;
  img = renameOli(img);
  //img = fmask(img);
  //img = calcNbr(img);
  //img = calc_ConProb(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}

// Define function to prepare ETM+ images (and TM).
function prepEtm(img) {
  var orig = img;
  img = renameEtm(img);
  //img = fmask(img);
  img = etmToOli(img);
  //img = calcNbr(img);
  //img = calc_ConProb(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}
////////////////////////////////////////
//End Landsat Harmonization functions///
////////////////////////////////////////


//Function to add an NDVI band to an image
var addQualityBands = function(image) {
  return image
    // NDVI
    .addBands(image.normalizedDifference(['nir', 'red']))
    // time in days
    .addBands(image.metadata('system:time_start'));
};

//Function to extract training data from imagery in specific training areas
function getTrainTestData(startDate,endDate,area,wStartDate,wEndDate){
var collection = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR")
.filterBounds(area)
.filterDate(startDate,endDate) 
.filter(ee.Filter.lt('CLOUD_COVER_LAND', 15))
.map(prepOli)
.map(addQualityBands);

var img = terrainCorrection(collection).qualityMosaic('nd');

var trainAndTestData = img.select(outBands).sampleRegions({ 
  collection: area,
  properties: ['pctCover'],
  scale: 30
});

return(trainAndTestData.randomColumn('random'));
}

//function to extract image of a certain date and area

function getImage(startDate,endDate,area){
var collection = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR")
.filterBounds(area)
.filterDate(startDate,endDate) 
.filter(ee.Filter.lt('CLOUD_COVER_LAND', 15))
.map(prepOli)
.map(addQualityBands);

var img = terrainCorrection(collection).qualityMosaic('nd');

return(img);
}


////reduce resolution//////
var reduceResolution = function(img,input_crs,output_crs){
  var tmp = img
    .setDefaultProjection(input_crs)
    // Force the next reprojection to aggregate instead of resampling.
    .reduceResolution({
      reducer: ee.Reducer.mean(),
       maxPixels: 1324
    })
    .reproject({
      crs: output_crs
    });
    return(tmp);
};

exports.reduceResolution = reduceResolution;

///////////////////////////////
//Terrain correction function//
///////////////////////////////
//Source: https://mygeoblog.com/2018/10/17/terrain-correction-in-gee/
var terrainCorrection = function(collection) {
 
  collection = collection.map(illuminationCondition);
  collection = collection.map(illuminationCorrection);
 
  return(collection);
 
  ////////////////////////////////////////////////////////////////////////////////
  // Function to _ion by Patrick Burns and Matt Macander
  function illuminationCondition(img){
 
  // Extract image metadata about solar position
  var SZ_rad = ee.Image.constant(ee.Number(img.get('SOLAR_ZENITH_ANGLE'))).multiply(3.14159265359).divide(180).clip(img.geometry().buffer(10000));
  var SA_rad = ee.Image.constant(ee.Number(img.get('SOLAR_AZIMUTH_ANGLE')).multiply(3.14159265359).divide(180)).clip(img.geometry().buffer(10000));
  // Creat terrain layers
  var slp = ee.Terrain.slope(dem).clip(img.geometry().buffer(10000));
  var slp_rad = ee.Terrain.slope(dem).multiply(3.14159265359).divide(180).clip(img.geometry().buffer(10000));
  var asp_rad = ee.Terrain.aspect(dem).multiply(3.14159265359).divide(180).clip(img.geometry().buffer(10000));
 
  // Calculate the Illumination Condition (IC)
  // slope part of the illumination condition
  var cosZ = SZ_rad.cos();
  var cosS = slp_rad.cos();
  var slope_illumination = cosS.expression("cosZ * cosS",
                                          {'cosZ': cosZ,
                                           'cosS': cosS.select('slope')});
  // aspect part of the illumination condition
  var sinZ = SZ_rad.sin();
  var sinS = slp_rad.sin();
  var cosAziDiff = (SA_rad.subtract(asp_rad)).cos();
  var aspect_illumination = sinZ.expression("sinZ * sinS * cosAziDiff",
                                           {'sinZ': sinZ,
                                            'sinS': sinS,
                                            'cosAziDiff': cosAziDiff});
  // full illumination condition (IC)
  var ic = slope_illumination.add(aspect_illumination);
 
  // Add IC to original image
  var img_plus_ic = ee.Image(img.addBands(ic.rename('IC')).addBands(cosZ.rename('cosZ')).addBands(cosS.rename('cosS')).addBands(slp.rename('slope')));
  return img_plus_ic;
  }
 
// Function to apply the Sun-Canopy-Sensor + C (SCSc) correction method to each
// image. Function by Patrick Burns and Matt Macander
 
function illuminationCorrection(img){
    var props = img.toDictionary();
    var st = img.get('system:time_start');
 
    var img_plus_ic = img;
    var mask1 = img_plus_ic.select('nir').gt(-0.1);
    var mask2 = img_plus_ic.select('slope').gte(5)
                            .and(img_plus_ic.select('IC').gte(0))
                            .and(img_plus_ic.select('nir').gt(-0.1));
    var img_plus_ic_mask2 = ee.Image(img_plus_ic.updateMask(mask2));
 
    // Specify Bands to topographically correct
    var bandList = ['blue','green','red','nir','swir1','swir2'];
    var compositeBands = img.bandNames();
    var nonCorrectBands = img.select(compositeBands.removeAll(bandList));
 
    var geom = ee.Geometry(img.get('system:footprint')).bounds().buffer(10000);
 
    function apply_SCSccorr(band){
      var method = 'SCSc';
      var out = img_plus_ic_mask2.select('IC', band).reduceRegion({
      reducer: ee.Reducer.linearFit(), // Compute coefficients: a(slope), b(offset), c(b/a)
      geometry: ee.Geometry(img.geometry().buffer(-5000)), // trim off the outer edges of the image for linear relationship
      scale: 300,
      maxPixels: 1000000000
      });  
 
   if (out === null || out === undefined ){
       return img_plus_ic_mask2.select(band);
       }
 
  else{
      var out_a = ee.Number(out.get('scale'));
      var out_b = ee.Number(out.get('offset'));
      var out_c = out_b.divide(out_a);
      // Apply the SCSc correction
      var SCSc_output = img_plus_ic_mask2.expression(
        "((image * (cosB * cosZ + cvalue)) / (ic + cvalue))", {
        'image': img_plus_ic_mask2.select(band),
        'ic': img_plus_ic_mask2.select('IC'),
        'cosB': img_plus_ic_mask2.select('cosS'),
        'cosZ': img_plus_ic_mask2.select('cosZ'),
        'cvalue': out_c
      });
 
      return SCSc_output;
    }
 
    }
 
    var img_SCSccorr = ee.Image(bandList.map(apply_SCSccorr)).addBands(img_plus_ic.select('IC'));
    var bandList_IC = ee.List([bandList, 'IC']).flatten();
    img_SCSccorr = img_SCSccorr.unmask(img_plus_ic.select(bandList_IC)).select(bandList);
 
    return img_SCSccorr.addBands(nonCorrectBands)
      .setMulti(props)
      .set('system:time_start',st);
  }
 
};  
///////////////////////////////////
//End terrain correction function//
///////////////////////////////////


//Function to predict percent conifer cover from lansdsat imagery
//this function requires that the imagery has been:

//1) harmonized
//2) terrain corrected
//3) processed to get the least cloudy summer image

function CalcConProb(img) {
  return img.classify(RFclassifier).rename('pctConCov');
  //.set('system:time_start', img.get('system:time_start'));
}


//////////////////////
///Main Code//////////
//////////////////////


/////////////////////////////////////////////
///Step 1. Train classification algorithm////
/////////////////////////////////////////////

//Get training data from Landsat images within the training areas
var trainAndTestData2014 = getTrainTestData('2014-06-30','2014-09-30',training2014,'2014-01-01','2014-04-15');
var trainAndTestData2015 = getTrainTestData('2015-06-30','2015-09-30',training2015, '2015-01-01','2015-04-15');
var trainAndTestData2016 = getTrainTestData('2016-06-30','2016-09-30',training2016, '2016-01-01','2016-04-15');
var trainAndTestData2017 = getTrainTestData('2017-06-30','2017-09-30',training2017, '2017-01-01','2017-04-15');
var trainAndTestData2019 = getTrainTestData('2019-06-30','2019-09-30',training2019, '2019-01-01','2019-04-15');
var trainAndTestData2021 = getTrainTestData('2021-06-30','2021-09-30',training2021, '2021-01-01','2021-04-15');

//Merge all training data
var allTrainAndTestData = trainAndTestData2014
.merge(trainAndTestData2015)
.merge(trainAndTestData2016)
.merge(trainAndTestData2017)
.merge(trainAndTestData2019)
.merge(trainAndTestData2021);

//Split data for training and testing
var split = 0.9;  //
var trainingPartition = allTrainAndTestData.filter(ee.Filter.lt('random', split));
var testingPartition = allTrainAndTestData.filter(ee.Filter.gte('random', split));

//Train the random forest algorithm
var RFclassifier = ee.Classifier.smileRandomForest(500).setOutputMode('REGRESSION')
.train(trainingPartition,"pctCover",outBands);


///////////////////////////////////////////////
//get predictions in the training areas////////
///////////////////////////////////////////////


var pred_img_2021 = conCoverL8('2021');
var pred_in_polys_2021 = pred_img_2021.reduceRegions({
  collection: training2021,
  reducer: ee.Reducer.mean(),
  crs: landsatProjection,
  scale: 30
});


var pred_img_2014 = conCoverL8('2014');
var pred_in_polys_2014 = pred_img_2014.reduceRegions({
  collection: training2014,
  reducer: ee.Reducer.mean(),
  crs: landsatProjection,
  scale: 30
});

var pred_img_2015 = conCoverL8('2015');
var pred_in_polys_2015 = pred_img_2015.reduceRegions({
  collection: training2015,
  reducer: ee.Reducer.mean(),
  crs: landsatProjection,
  scale: 30
});

var pred_img_2016 = conCoverL8('2016');
var pred_in_polys_2016 = pred_img_2016.reduceRegions({
  collection: training2016,
  reducer: ee.Reducer.mean(),
  crs: landsatProjection,
  scale: 30
});

var pred_img_2017 = conCoverL8('2017');
var pred_in_polys_2017 = pred_img_2017.reduceRegions({
  collection: training2017,
  reducer: ee.Reducer.mean(),
  crs: landsatProjection,
  scale: 30
});


var pred_in_polys = pred_in_polys_2014.merge(
pred_in_polys_2015).merge(
pred_in_polys_2016).merge(
pred_in_polys_2017).merge(
pred_in_polys_2021);

//print(pred_in_polys,'pred');

/*
Export.table.toDrive({
  collection: pred_in_polys, 
  description: 'trainingPlotPredictions_4_26_2022',
  folder: 'validation',
  fileFormat: 'CSV'
});
*/

/*
.reduceNeighborhood({
  reducer: ee.Reducer.mean(),
  kernel: ee.Kernel.square(1.5),
});
*/

///////////////////////////////////////////////////////
////Step 2. Classify landsat archive in study area ////
///////////////////////////////////////////////////////




//Map.addLayer(img,LandsatVizParams,"2021");
//Map.addLayer(conCoverL8('2021'),{min:0.15,max:0.85,palette:['brown','green']},'pct con cover 2021 30 m');
//Map.addLayer(conCoverL8('2020'),{min:0.15,max:0.85,palette:['brown','green']},'pct con cover 2020');



//get landsat 8 stack (2013-present)
var conCoverL8_stack = ee.ImageCollection((['2021','2020','2019','2018','2017','2016','2015','2014','2013'])
    //.updateMask(studyPixels)
    .map(conCoverL8));

exports.conCoverL8_stack = conCoverL8_stack;

//get landsat 7 stack (1999-2012)
var conCoverL7_stack = ee.ImageCollection((['2012','2011','2010','2009','2008','2007','2006','2005','2004','2003','2002','2001','2000','1999'])
    //.updateMask(studyPixels)
    .map(conCoverL7));

exports.conCoverL7_stack = conCoverL7_stack;

//get landsat 5 stack (1984-1998)
var conCoverL5_stack = ee.ImageCollection((['1998','1997','1996','1995','1994','1993','1992','1991','1990','1989','1988','1987','1986','1985','1984'])
    //.updateMask(studyPixels)
    .map(conCoverL5)); 

exports.conCoverL5_stack = conCoverL5_stack;

var conPctCover = conCoverL8_stack.merge(conCoverL7_stack).merge(conCoverL5_stack);
//print(conPctCover,'conPctCov');

exports.conPctCover = conPctCover;
//print(conCoverL8_stack);

///////////////////
//////////scratch//
///////////////////



/*
var exportConCov = function(fa,yr){
  
var focalArea = focalAreas
.filter(ee.Filter.eq('id', fa))
.geometry();

var focalAreaString = ee.String(ee.Number(fa));
var yearString = ee.String(ee.Number(yr));
var bandString = ee.String('conCov').cat(yearString);

Export.image.toDrive({image: conPctCover_reproj.select(bandString), 
                      description: bandString.cat(focalAreaString).getInfo(),
                      region: focalArea,
                      crs: projFinal.crs,
                      crsTransform: projFinal.transform,
                      folder:"conCov",
                      maxPixels: 1e11
                      });

  
};
*/



//Map.addLayer(studyPixels,{min:0,max:1,palette:['white','black']},'studyPixels');

//prior tests
//Test 1
//reduce rez after classification, 2021, study area to asset
//didn't work, ran out of memory
/*
Export.image.toAsset({image: conPctCover_reproj_cache.select('conCov2021'), 
                      description: 'conPctCover_reproj_cache_2021',
                      region: study_area,
                      crs: projFinal.crs,
                      crsTransform: projFinal.transform,
                      maxPixels: 1e10
                      });
*/


//Test 2.
//Don't set default resolution, reduce resolution, or reproject to target before export
//During export set target resolution, set tiling policy to mean
//I think this draws upon larger tiles sizes during the whole classification process.
//Export size: study area
//Is it ok that the mosaic doesn't have a projection assigned?
//Next test can assign a projection, but leave everything else the same and see if that makes a difference

/*
Export.image.toDrive({image: conPctCover.first().updateMask(studyPixels), 
                      description: 'conCover2021_geom_noPreExportReproj',
                      region: geometry,
                      crs: projFinal.crs,
                      crsTransform: projFinal.transform,
                      maxPixels: 1e10
                      });
*/
//Test 3
//Full reproj process 2021 geometry

/*
Export.image.toDrive({image: conPctCover_reproj.select('conCov2021'), 
                      description: 'conCover2021_geom_fullReproj',
                      region: geometry,
                      crs: projFinal.crs,
                      crsTransform: projFinal.transform,
                      maxPixels: 1e10
                      });

*/
